<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style type="text/css">
        * {
            box-sizing: border-box;
            margin: 0;
        }

        main {
            width: 900px;
            margin: 0 auto;
        }

    </style>
</head>
<body>
    <header></header>
    <nav></nav>
    <main>
        <pre>
        <article>
            <h1>CSS Notes</h1>
        
                CSS or Cascading Style Sheets is a rule based language. 
                The rule opens with a selector . This selects the HTML element that we are going to style. 

                We then have a set of curly braces { }. Inside those will be one or more declarations, 
                which take the form of property and value pairs. Each pair specifies a property of the element(s) we are selecting, 
                then a value that we'd like to give the property.
                
                Before the colon, we have the property, and after the colon, the value. 
                CSS properties have different allowable values, depending on which property is being specified
                


            <h2>Getting started</h2>

                * There are three different ways to apply CSS to an HTML document: using a link element (external style sheet), 
                    inside style tag (internal style sheet) and with style tag in html element (inline css declaration).
                
                * Targeting an element selector — this is a selector that directly matches an HTML element name 
                
                * p,li {
                    color: red;
                }

                * The browser is adding some default styling to html elements to make it readable you can override that as well 
                    with your custom css, e.g. to remove default bullet points from list items, 
                    li {
                        list-style-type: bengali;
                    }
                    all html element that has display type of list-item can be targetted and their style can be changed as above. 
                
                * select a subset of element without changing the other element of same type; in such case use class attribute.
                    
                    <li class="special">Item special</li>

                    and style it by,
                    .special{
                        color: red;
                    } 
                    class selector starts with fullstp "."
                    any element whose class attribute is set to value "special" will take effect of the above css rule. 
                
                * Select element more specifically, 
                    li.special{
                        color: red;
                    }
                    target any li element that has a class of special, 
                    In this case any other element with class specials will be affected by above css rule.
                
                * It is sometimes best to bypass the element and refer to the class, unless you know that you want to create 
                    some special rules for one element alone, and perhaps want to make sure they are not applied to other things
                
                * Descendant combinator, which takes the form of a space " " between two other selectors.
                    li em {
                        color: rebeccapurple;
                    }
                    select the em element which is(/are) nested inside (Descendant of) li.

                * Adjacent sibling combinator, place a plus sign "+" between two selector, 
                    h1 + p {
                        font-weight: bold;
                    }
                    styles the first paragraph that comes directly after a top level heading h1. 
                
                * Styling based on state, 
                    a:link , a:hover, a:visited {
                        
                    }
                    link should always be underlined. 
                
                * Combining selector and combinator
                    /* selects any <span> that is inside a <p>, which is inside an <article>  */
                        article p span { ... }
                        
                    /* selects any <p> that comes directly after a <ul>, which comes directly after an <h1>  */
                    h1 + ul + p { ... }

                    /* You can combine multiple types together, too. Try adding the following into your code: */
                    body h1 + p .special {
                        color: yellow;
                        background-color: black;
                        padding: 5px;
                    }
                    
                    This will style any element with a class of special, which is inside a <p>, which comes just after an <h1>, 
                        which is inside a <body>.
                


            <h2> How CSS is structured </h2>
                
                * CSS resolves conflicting styling rules by two basic rule such as "The Cascading rule" and "The specificity rule"

                * CSS styling rule that appear later in stylesheet replaces earlier conflicting styling rule;
                    this is called "The Cascading rule"
                
                * CSS styling rule with a class selector will replace styling rules that are applied only with element selectors. 
                    this is called "the specificity rule"
                
                * Basic structure, 

                    h1 {                                                                |selector   |
                        color: blue;            | css declaration |                                 | CSS Rulesets/Rules
                        font-weight: bold;      | css declaration | css declaration block           | e.g. h1 rule
                        background-color:white; | css declaration |                                 | 
                    }                                                                               |
                
                * Avoid using inline css and only when neccessary use internal if possible or inline othewise
                
                * The CSS engine calculates which declarations apply to every single element of a page.

                * CSS properties and values are case-insensitive. The property and value in a property-value 
                    pair are separated by a colon (:).
                
                * If a property is unknown, or if a value is not valid for a given property, 
                    the declaration is processed as invalid. It is completely ignored by the browser's CSS engine.
                
                *  In CSS (and other web standards), it has been agreed that US spelling is the standard where there 
                    is language variation or uncertainty. For example, colour should be spelled color, as colour will not work.
                
                * functions such as "calc()" can be used as a value to "width" property; simple maths can be performed using it. 
                
                * "transform" property also takes other functions as value such as "rotate(0.8turn)"

                * CSS @at-rules defines what CSS should perform and how it should behave. e.g, 
                    @include 'style2.css'

                    @media (max-width: 800px){
                        body{
                            background-color: blue;
                        }
                    }
                
                * Shorthand properties set several values at once. Properties such as font, background, padding, 
                    border, margin etc,
                
                In 4-value shorthands like padding and margin, the values are applied
                in the order top, right, bottom, left (clockwise from the top). 

                There are also other shorthand types, for example 2-value shorthands, which set padding/margin
                for top/bottom, then left/right

                    - padding: 10px 15px 15px 5px;
                    is equivalent to these four lines of code:

                    padding-top: 10px;
                    padding-right: 15px;
                    padding-bottom: 15px;
                    padding-left: 5px;
                    
                    
                    - background: red url(bg-graphic.png) 10px 10px repeat-x fixed;
                    is equivalent to these five lines:

                    background-color: red;
                    background-image: url(bg-graphic.png);
                    background-position: 10px 10px;
                    background-repeat: repeat-x;
                    background-attachment: fixed;
                
                * A value not specified in CSS shorthand reverts to its initial value. This means an omission 
                    in CSS shorthand can override previously set values. Also any value that is invalid for a property 
                    in a shorthand will be passed on to the next property and skipped property's value will be resetted to 
                    their respective intial value.
                * /* CSS comments */
                * White spaces in CSS is also ignored by the browser. 
                * Though property values can be separated by space but there should not be any space between property name. 



            <h2>How CSS works</h2>

                * How a page is rendered by the browser, 
                    * How a page is rendered by the browser, 
                * How a page is rendered by the browser, 
                    1. Fetch the HTML.
                    2. Convert HTML to DOM.
                    3. Fetch all linked resources such as video, img, audio and CSS. Javascript is loaded later.
                    4. Parse CSS and sort them in different buckets based on their selector types. Figure out which
                        rules should be applied to which node in DOM and attaches style to them. (Render Tree)
                    5. The render tree is laid out in the structure it should appear in after the rules 
                        have been applied to it.
                    6. The visual display is showed on the screen.

                * Browser just ignores CSS declaration that is not understood and move on to next declaration.

                * Also if a selector is not valid in a list of selectors browser will just ignore the whole ruleset. 



            <h2>Cascade and Inheritance</h2>
                
                * Cascade: When two rules with same specificity are intend to apply to the same element then 
                    rule that comes later while parsing and interpretation will be effective overriding the other
                    that came earlier
                
                * Inheritance: Some element inherits specified value that is set to their parent's element and some do not. 

                * Specificity: In a situation where two conflicting rules with different selectors that applies 
                    to the same element then the rule which has more specific selector will be effective.
                
                * Inline css (1000) > id selector (0100) > class, attribute and pseudo-class (0100) > 
                    element and pseudo element  > parent element selector

                * Not Inherited properties: width, margin, padding, border; 
                
                * Inherited properties: 

                * Controlling Inheritance
                    CSS provides four special universal property values for controlling inheritance. 
                    Every CSS property accepts these values.
                    
                    - Inherit: Sets the property value applied to a selected element to be the same as that of its parent element. 
                        Effectively, this "turns on inheritance".
                    
                    - Initial: Sets the property value applied to a selected element to the initial value of that property.
                        The initial value of a CSS property is its default value, as listed in its definition table in the 
                        specification. 
                        
                        The usage of the "initial value" depends on whether a property is inherited or not:
                            For inherited properties, the initial value is used (applied ?) on the root element only, 
                            as long as no specified value is supplied and other child elements just inhertis, I suppose.
                            (ইনহেরিটেড প্রপারটিস এর ইনিশিয়াল ভ্যালুটা রুট ইলিমেন্টে সেট করা থাকে)

                            For non-inherited properties, the initial value is used on all elements,
                            as long as no specified value is supplied.
                            (নন-ইনহেরিটেড প্রপারটিস এর ইনিশিয়াল ভ্যালু প্রত্যেক ইলিমেন্টের জন্য আলাদা আলাদা ভাবে সেট করা থাকে)

                        You can explicitly specify the initial value by using the initial keyword.
                        Note: The initial value should not be confused with the value specified by the browser's style sheet.

                    - Unset: Resets the property to its natural value, which means that if the property 
                        is naturally inherited it acts like inherit, otherwise it acts like initial (CSS default value).
                    
                    - Revert: Acts like unset in many cases, however will revert the property to the browser's default 
                        styling rather than the defaults applied to that property.
                
                * The universal selector (*), combinators (+, >, ~, ' '), and negation 
                    pseudo-class (:not) have no effect on specificity.
                
                * !important rules override all other conflicting rules; The only way to override this 
                    !important declaration would be to include another !important declaration on a declaration with the 
                    same specificity later in the source order, or one with higher specificity.
                    
                * It is recommended to use !important only when there is no other way. 

                * A common practice is to define generic styles for the basic elements,
                    and then create classes for those which are different
                    


            <h2> Selectors </h2>

                * The element or elements which are selected by the selector are referred to as the subject of the selector.

                * Selector list: if you need to apply the same style to multiple elements then you can list their selectors
                    by comma ",". A white space is permitted to use before or after comma for better readablity.
                    Note: if a selector in a selector list is invalid then the whole rullset is ignored.
                
                * Selector types:
                    - Element/type/tag name e.g.,   h1 { }                          //  all h1 elements. 

                    - Class  e.g.,                  .special { }                    //  all elements with class "special".

                    - Id  e.g.,                     #unique { }                     //  only element with id "unique".

                    - Attribute  e.g.,              a[title] { }                    //  all anchor elements that have a title attribute present.
                    
                    - Attribute value  e.g.,        a[href="http://example.com"]    //  all anchor elements that have their href attribute set to "http://example.com"
                    
                    - pseudo-class  e.g.,           a:hover                         //  selects only a certain state of an element, in this case when link is hovered by a mouse. 
                    
                    - pseudo-element e.g.,          p:first-line                    //  always selects first-line of text inside an element in this case, p (paragraph).
                    
                    - Combinators
                        this type of selectors combine other selectors in order to target elements, 
                        - child combinator e.g.,    article > p                 // all paragraphs that are direct children of article element.
                    
                    - Universal selector: indicated by an asterisk (*). It selects everything in the document 
                        (or inside the parent element if it is being chained together with another element and a descendant combinator)
                        often can be seen in "reset stylesheets" and to increase readability of other selectors. 

                    - more specific selection by chaining multiple type of selector
                        .notebox.danger { color: blue; } // select element which has class notebox and danger. 
                        h1.special { font-weight: 400; } // select h1 element which has class special. 
                    
                    - Using the same ID multiple times in a document may appear to work for styling purposes, but don't do this. 
                        It results in invalid code, and will cause strange behavior in many places
                        and it is preferale in most cases to use class instead of an ID.
                    
                * Attribute value selector and specifier, 
                    - Attribute selector                                        element[attribute] { }
                    - if attribute has a specific value                         a[href="http://example.com"] { }
                    - if attribute value is present within list of values       p[class~="special"] { }     // select all paragrph elements which have class "special" in their assigned class list. 
                    - if attribute value is exact or followed by a hyphen       div[lang|="es"]     { }     // selects all div if their "lang" attribute is set to "es" or "es-"
                    - if attribute value starts with query value                li[class^="box-"]   { }     // selects all list items if their "class" attribute value starts with "box-"
                    - if attribute value ends with query value                  li[class$="-box"]   { }     // if class value ends with "-box" 
                    - if query value is present anywhere within attribute value li[class*="box"]    { }     // if class value contains "box" within any of its class values, e.g., sample-box-one
                    - case insensitive attribute value selector                 li[class="box" i]   { }     // matches if class value is set to either "box" or "BOX"
                    - case sensitive attribute value selector                   li[class="BOX" s]   { }     // selects only if class="BOX"
                
                * :pseudo-class 
                    A pseudo-class is a selector that selects elements that are in a specific state, 
                    e.g. they are the first element of their type, or they are being hovered over by the mouse pointer.
                    such as :first-child, :last-child, :only-child etc. 
                    
                    - Some pseudo-class elements are called user-action or dynamic pseudo class elements 
                        because those pseudo class beahaves in a way such that a class has been added to the elements at the 
                        moment when user interacts with it, e.g., :hover, :active
                    
                    pseudo class selector keywords starts with a single colon, :pseudo-class
                
                * ::pseudo-element 
                    Similar to the pseudo-class but they act as if you had added a whole new HTML element into the markup, 
                    rather than applying a class to existing elements. Pseudo-elements start with a double colon ::.
                    Also, browser supports pseudo elements with single colon for backwards compatibility. 
                
                * pseudo-class and pseudo-element can be chained together. 
                    article p:first-child::first-line { } // first line of first paragraph inside article element. 
                    p:first-child   => a paragraph element who is first child of its parent, 
                
                * Generating content with pseudo-element ::before and ::after along with content property
                    p::after{
                        content: "A string; can also be empty";
                        dispaly: block; 
                        width: 10px;
                        height: 10px; 
                        color: white;
                        background-color: green; 
                        border: 2px solid black; 
                    }
                
                    A more valid use of these pseudo-elements is to insert an icon, for example the little arrow added 
                    in the example below, which is a visual indicator that we wouldn't want read out by a screenreader.
                
                    We have set this to display: block in order that we can style it with a width and height.

                * Reference: https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements
                
                * Combinators: 
                    - Descendant combinator: denoted by a single space / " " ; selects all descendant elements.
                        
                        combines two selectors such that elements matched by the second selector are selected if they have an ancestor 
                        (parent, parent's parent, parent's parent's parent, etc) element matching the first selector. Selectors that 
                        utilize a descendant combinator are called descendant selectors.
                    
                    - Child combinator: denoted by a greater-than sign / " > "; selects all direct children elements. 
                        does not select other descendant elements that are further down the hierarchy. 
                        For example, ul > li { } // will select all li items that are direct children of ul but not any li elements 
                        that are nested inside direct children elements. 

                    - Adjacent sibling combinator: denoted by a plus sign / " + "; selects all adjacent element that are very next to 
                        preceding element. 
                        p + img { } // select all img elements that are next to a paragraph.
                    
                    - General sibling combinator: denoted by a tilde sign / " ~ " ; selects all sibling elements even if they are far away from their parent.
                        If you want to select siblings of an element even if they are not directly adjacent, then you can use the 
                        general sibling combinator (~). To select all <img> elements that come anywhere after <p> elements, we'd do this:
                            p ~ img { } //
                    
                    - All selectors can be chanied to specifically target an element but specific selectors are only useful if 
                        you are absolutely sure that those css rules will not be applied to other rules. 
                


            <h2>The Box Model</h2>
                
                Everything in CSS has a box around it.
                There are two display types for every box
                1. Inner display type 
                2. Outer display type
                
                There are two outer display types for all boxes, 
                1. Block Box
                2. Inline Box

                You can select an element and set the inner display type to inline then the outer display type automatically 
                changes to block, alternatively when you set an element's outer display type to block then its inner display 
                type changes to inline. 

                * If a box has an outer display type of block, it will behave in the following ways:

                    The box will break onto a new line.
                    The box will extend in the inline direction to fill the space available in its container. 
                    In most cases this means that the box will become as wide as its container, filling up 100% of the space available.
                    The width and height properties are respected.
                    Padding, margin and border will cause other elements to be pushed away from the box
                    Some HTML elements, such as <h1> and <p>, use block as their outer display type by default.

                * If a box has an outer display type of inline, then:

                    The box will not break onto a new line.
                    The width and height properties will not apply.
                    Vertical padding, margins, and borders will apply but will not cause other inline boxes to move away from the box.
                    Horizontal padding, margins, and borders will apply and will cause other inline boxes to move away from the box.
                    Some HTML elements, such as <a>, <span>, <em> and <strong> use inline as their outer display type by default.

                The type of box applied to an element is defined by display property values such as block and inline, 
                and relates to the outer value of display.
                
                - Outer display type dictates how an element is laid out in its parent container with respect to other sibling elements.
                - inner display type, however, which dictates how elements inside that box are laid out. By default, the elements inside a box are 
                    laid out in normal flow, which means that they behave just like any other block and inline elements (as explained above).
                
                Outer display type values: block , inline. 
                Inner display type values: flex, grid, 

                -  If we set display: flex; on an element, the outer display type is block, but the inner display type is changed to flex. 
                Any direct children of this box will become flex items and will be laid out according to the rules set out in the Flexbox spec,
                


                * CSS BOX MODEL 
                    - The CSS box model as a whole applies to block boxes. Inline boxes use just some of the behavior defined in 
                        the box model.


                    There are four parts to a css box, 
                        - Content box: The area where your content is displayed, which can be sized using properties like width and height.

                        - Padding box: The padding sits around the content as white space; its size can be controlled using padding and 
                            related properties.

                        - Border box: The border box wraps the content and any padding. Its size and style can be controlled 
                            using border and related properties.

                        - Margin box: The margin is the outermost layer, wrapping the content, padding, and border as whitespace between 
                            this box and other elements. Its size can be controlled using margin and related properties.
                    
                            
                    There are two types of box model, 

                        - Standarad Box Model 
                            if you give a box a width and a height attribute, this defines the width and height of the content box. 
                            Any padding and border is then added to that width and height to get the total size taken up by the box.
                            
                            box-sizing: content-box;

                        - Alternate Box Model
                            any width is the width of the visible box on the page, therefore the content area width is that width minus 
                            the width for the padding and border.

                    * Note: The margin is not counted towards the actual size of the box — sure, it affects the total space that 
                        the box will take up on the page, but only the space outside the box. The box's area stops at the border — 
                        it does not extend into the margin.
                    
                    * By default, browsers use the standard box model. If you want to turn on the alternative model for an element, 
                        you do so by setting box-sizing: border-box on it.

                        html {
                            box-sizing: border-box;
                          }
                          
                        *, *::before, *::after {
                        box-sizing: inherit;
                        }
                    

                    * Margin 
                        The margin is an invisible space around your box. It pushes other elements away from the box. Margins can have positive or negative 
                        values. Setting a negative margin on one side of your box can cause it to overlap other things on the page. Whether you are using 
                        the standard or alternative box model, the margin is always added after the size of the visible box has been calculated.
                        
                        margin: top right bottom left; 

                        margin-top: 10px;
                        margin-right: 10px;
                        margin-bottom: 10px; 
                        margin-left: 10px;


                    * Border 
                        The border is drawn between the margin and the padding of a box. If you are using the standard box model, 
                        the size of the border is added to the width and height of the box. If you are using the alternative box 
                        model then the size of the border makes the content box smaller as it takes up some of that available width and height.

                        border: 1px solid black; 
                        border => top right bottom left color style width


                    * Padding 
                        The padding sits between the border and the content area. Unlike margins, you cannot have negative amounts of padding, 
                        so the value must be 0 or a positive value. Padding is typically used to push the content away from the border. 
                        Any background applied to your element will display behind the padding.

                        padding: top right bottom left; 

                        padding-top: 
                        padding-right: 
                        padding-bottom: 
                        padding-left: 

                        padding: 1em; // all four sides
                        padding: 1em 2em; // top and bottom 1em, right and left 2em
                        padding: 1em 2em 3em; // top 1em, right and left 2em, bottom 3em
                        
                    

                    * The Box Model and Inline boxes 
                        width and height are not respected 
                        margin, padding and border is effective only. 
                        
                        The vertical margin, padding, and border are respected but they do not change the relationship 
                        of other content to our inline box and so the padding and border overlaps other words in the paragraph. 
                        Horizontal padding, margins, and borders are respected and will cause other content to move away from the box.


                    * The inline-block boxes
                        outer display type: inline 
                        inner display type: block 
                        
                        do not break into a new line but also respect height and width along with margin padding border.

                    * Margin -> Border -> Padding -> Content (boxes)

                    * Margin collapsing: when two margin collapse vertically then the bigger margin merges with the smaller one 
                        and the bigger margin persists.


                        
            <h2> Background and Borders</h2>

                * background-color: <color>;
                * background-image: url();
                    Enables us to show a image in the background of a box. 
                    By default, the large image is not scaled down to fit the box, so we only see a small corner of it, 
                    whereas the small image is tiled to fill the box.
                * Background also includes the padding around the content box.
                * If you specify a background color in addition to a background image then the image displays on top of the color.

                * background-repeat: 
                    The background-repeat property is used to control the tiling behavior of images. 
                    
                    The available values are:
                        no-repeat — stop the background from repeating altogether.
                        repeat-x — repeat horizontally.
                        repeat-y — repeat vertically.
                        repeat — the default; repeat in both directions.
                
                * Sizing the Background Image 
                    background-size: <length> <percentage> or, 
                        - cover
                            the browser will make the image just large enough so that it completely covers the box area while 
                            still retaining its aspect ratio. In this case, part of the image is likely to end up outside the box.

                        - contain
                            the browser will make the image the right size to fit inside the box. In this case, you may end up 
                            with gaps on either side or on the top and bottom of the image, if the aspect ratio of the image is 
                            different from that of the box.
                        
                        background-size: 10px; // width; height becomes auto; 
                        background-size: 10px 20px; //width height; 
                        background-size: 20px 10px, auto; 
                        // multiple backgrond image size; such that, first has 20px width and 10px height and 2nd has width and height of auto
                
                * Background Positioning
                    The background-position property allows you to choose the position in which the background image appears on 
                    the box it is applied to. This uses a coordinate system in which the top-left-hand corner of the box is (0,0), 
                    and the box is positioned along the horizontal (x) and vertical (y) axes.
                    Note: The default background-position value is (0,0).
                    
                    Single value: 
                        One of the keyword values top, left, bottom, right. This specifies an edge against which to place the item. 
                        The other dimension is then set to 50%, so the item is placed in the middle of the edge specified.
                    
                    Double value
                        background-position: horizontal vertical ; //value in length percentage or,
                        top, right, bottom, left, center.
                    
                    4 Value Syntax
                        in order to indicate a distance from certain edges of the box — the length unit, in this case, 
                        is an offset from the value that precedes it. 
                        background-position: top 20px right 10px;
                    
                    background position is shorthand for 
                        background-position-x: 
                        background-position-y: 

                * Gradiant Backgrounds 
                    background-image: linear-gradient();
                    background-image: radial-gradient();
                    background-image: conic-gradient();
                    background-image: repeating-linear-gradient();
                    background-image: repeating-radial-gradient();

                    A gradient — when used for a background — acts just like an image and is also set by using the background-image property.


                * Multiple Background Images
                    
                - It is also possible to have multiple background images — you specify multiple background-image values in a single property value, 
                    separating each one with a comma.

                - When you do this you may end up with background images overlapping each other. The backgrounds will layer with the last listed 
                    background image at the bottom of the stack, and each previous image stacking on top of the one that follows it in the code.
                
                - Note: Gradients can be happily mixed with regular background images.
                
                - The other background-* properties can also have comma-separated values in the same way as background-image
                    If there are four background images but only two background-position values. The first two position values will 
                    be applied to the first two images, then they will cycle back around again for remaining images. 

                
                * Background Attachment 
                    
                    background-attachment: scroll, fixed, local. 

                    - scroll: the background-image does not scroll with the box (to which the image is set as background) content, 
                        but it scrolls with the page when the host box is scrolled with respect to the page. 

                    - fixed: the background-image is fixed to the viewport, does not scroll with the box or the page. 

                    - local: the background-image is fixed to the host box, scrolls with the box.


                * background short hand property 
                    
                    - If using multiple backgrounds, you need to specify all of the properties for the first background, 
                        then add your next background after a comma.
                    
                    - A background-color may only be specified after the final comma.
                    - The value of background-size may only be included immediately after background-position, separated with the '/' character, 
                        like this: center/80%.
                
                * border 
                    
                    - border-top: 1px solid black; 
                    - border-width: 10px; 
                    - border-top-width: 1px;
                    
                * Rouding borders 
                    
                    - border-radius: 10px; // rounds border 10px in x and y direction on all 4 corners.
                
            
            <h2>Different text directions</h2>

                CSS support differnt types of writing modes susch as left to right (conventional default), right to left (for Arabic)
                top to bottom (for Chinese and Japanese) 

                You can set different writing modes by using "writing-mode" property, valid values of this property are, 

                    - horizontal-tb: Top-to-bottom block flow direction. Sentences run horizontally.
                    - vertical-rl: Right-to-left block flow direction. Sentences run vertically.
                    - vertical-lr: Left-to-right block flow direction. Sentences run vertically.
                
                    So the writing-mode property is in reality setting the direction in which block-level elements are displayed on the page — 
                    either from top-to-bottom, right-to-left, or left-to-right. This then dictates the direction text flows in sentences.
                
                    When we switch the writing mode, we are changing which direction is block and which is inline. 
                    In a horizontal-tb writing mode the block direction runs from top to bottom; in a vertical-rl writing mode 
                    the block direction runs right-to-left horizontally. So the block dimension is always the direction 
                    blocks are displayed on the page in the writing mode in use. The inline dimension is always the direction a sentence flows.

                It is not neccessarily used to work with different languages of different text directions rather it is used for creative purposes. 

                So the block dimension is always the direction blocks are displayed on the page in the writing mode in use. 
                The inline dimension is always the direction a sentence flows.

                * Direction 
                    In addition to writing mode we also have text directions.


                * Logical property and value
                    Due to the fact that writing mode and direction of text can change, newer CSS layout methods
                    do not refer to left and right, and top and bottom. Instead they will talk about start and end 
                    along with this idea of inline and block. 

                    When we're in a vertical writing mode we want the box to expand in the block dimension just like it does in the horizontal mode.

                    To make this easier, CSS has recently developed a set of mapped properties. 
                    These essentially replace physical properties — things like width and height — with logical, 
                    or flow relative versions.

                    The property mapped to width when in a horizontal writing mode is called inline-size — 
                    it refers to the size in the inline dimension. The property for height is named block-size 
                    and is the size in the block dimension. You can see how this works in the example below where 
                    we have replaced width with inline-size.
                
                    If you change the writing mode of the boxes by switching the writing-mode property on .box to vertical-rl, 
                    you will see how the physical properties stay tied to their physical direction, whereas the logical 
                    properties switch with the writing mode.

                    Reference: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties (Logical Properties and Values).
                
                    
                
            <h2> Overflowing Content </h2>

                * Everything in CSS has a box around it. Overflow happens when there is too much content to fit in a box, 
                    overflow can happen in block direction and inline direction. 

                    overflow: overflow-x overflow-y; 
                    overflow: visible;
                    overflow-y: hidden; 
                    overflow-x: scroll; 
                    overflow: auto; 

                * if overflow happens in inline direction and a word is too big for the max-width of the container. 
                    overflow-wrap: anywhere, break, normal; 

                * When developing a site, always keep overflow in mind.
                

                    
            <h2>CSS Values and Units</h2>
                
                CSS value type / data type is denoted by a keyword enclosed within angle brackets e.g., <color>
                and properties are denoted by a keyword.

                    <integer>	    An <integer> is a whole number such as 1024 or -55.

                    <number>	    A <number> represents a decimal number — it may or may not have a decimal 
                                        point with a fractional component. For example, 0.255, 128, or -1.2.

                    <dimension>	    A <dimension> is a <number> with a unit attached to it. 
                                        For example, 45deg, 5s, or 10px. <dimension> is an umbrella category that 
                                        includes the <length>, <angle>, <time>, and <resolution> types.

                    <percentage>	A <percentage> represents a fraction of some other value. 
                                        For example, 50%. Percentage values are always relative to another quantity. 
                                        For example, an element's length is relative to its parent element's length.

                
                Absolute <length> units

                    Absolute length units
                    The following are all absolute length units — they are not relative to anything else, 
                    and are generally considered to always be the same size.

                    Unit	Name	            Equivalent to

                    cm	    Centimeters	        1cm = 37.8px = 25.2/64in
                    mm	    Millimeters	        1mm = 1/10th of 1cm
                    Q	    Quarter-millimeters	1Q = 1/40th of 1cm
                    in	    Inches	            1in = 2.54cm = 96px
                    pc	    Picas	            1pc = 1/6th of 1in
                    pt	    Points	            1pt = 1/72th of 1in
                    px	    Pixels	            1px = 1/96th of 1in

                
                Relative <length> units

                    Unit	Relative to

                    em	    Font size of the parent, in the case of typographical properties like font-size, 
                            and font size of the element itself, in the case of other properties like width.
                            font-size: 1.3em; // font size will be 1.3x of its parent element's font-size.
                            width: 10em; // width will be 10x of the element's font-size.
                    
                    ex	    x-height of the element's font.
                    
                    ch	    The advance measure (width) of the glyph "0" of the element's font.
                    
                    rem	    Font size of the root element.
                    
                    lh	    Line height of the element.
                    
                    vw	    1% of the viewport's width.
                    
                    vh	    1% of the viewport's height.
                    
                    vmin	1% of the viewport's smaller dimension.
                    
                    vmax	1% of the viewport's larger dimension.

                    Relative length units are relative to something else, perhaps the size of the 
                    parent element's font, or the size of the viewport.
                

                <percentage> units 
                    
                    The thing with percentages is that they are always set relative to some other value. 
                    For example, if you set an element's font-size as a percentage, it will be a percentage of 
                    the font-size of the element's parent. If you use a percentage for a width value, it will be 
                    a percentage of the width of the parent.
                    
                    If the allowed value includes <length-percentage> then you can use a length or a percentage. 
                    If the allowed value only includes <length>, it is not possible to use a percentage.

                Numbers
                        opacity: 0;
                        opacity: 1; 
                    

                Color 
                    The standard color system available in modern computers is 24 bit, which allows the display of 
                    about 16.7 million distinct colors via a combination of different red, green and blue channels 
                    with 256 different values per channel (256 x 256 x 256 = 16,777,216.) 

                    color: white; 
                    background-color: antiquewhite;

                Hexadecimal RGB values
                    #abcdef // #follwed by 6 hexadecimal characters; 2 hexadecimal characters per channel. 
                    color: #ff0000; 
                    is equivalen to, 
                    color: red; 

                RGB and RGBA values, 
                    color: rgb(red, green, blue) // each channel can have value ranged 0-255
                    color: rgba(red, green, blue, alpha) // alpha ranged 0-1
                    
                    Note: Setting an alpha channel on a color has one key difference to using the opacity property 
                    we looked at earlier. When you use opacity you make the element and everything inside it opaque, 
                    whereas using RGBA colors only makes the color you are specifying opaque.

                HSL and HSLA values

                    Hue: The base shade of the color. This takes a value between 0 and 360, representing the angles around a color wheel.

                    Saturation: How saturated is the color? This takes a value from 0–100%, where 0 is no color (it will appear as a 
                    shade of grey), and 100% is full color saturation

                    Lightness: How light or bright is the color? This takes a value from 0–100%, where 0 is no light 
                    (it will appear completely black) and 100% is full light (it will appear completely white)

                    color: hsl(188, 90%, 70%);
                    color: hsla(188, 90%, 70%, 0.7);
                    
                    try to use single color model throughout your project. 


                <position>
                    A typical position value consists of two values — the first sets the position horizontally, 
                    the second vertically. If you only specify values for one axis the other will default to center.


                Strings and identifiers
                    
                    <color> values such as black, white, purple, positional property values such as top, right, left, center
                        these kind of keywords are called identifiers. 

                    but for generated content we use string,
                    .box::after {
                        content: "This is a string. I know because it is quoted in the CSS."
                        }

                functions
                        color: rgb(); 

                        .box{
                        width: calc(20% + 100px); // 20% of the parents width + 100px 
                        }



            
            <h2>Sizing Items in CSS</h2>
                
                intrinsic size
                    original size of an element before it is affected by any css. 
                    <div></div> is a block level element which has intrinsic width as same as its parent. 
                    and intrinsic height is 0px if there is no content or it is determined by the content it contains. 

                extrinsic size
                    When a size is given to an element (the content of which then needs to fit into that size) 
                    we refer to it as an extrinsic size.
                
                margin and padding with percentage
                    When you use margin and padding set in percentages, the value is calculated from the inline size of 
                    the containing block — therefore the width when working in a horizontal language.

                min- and max- sizes
                    min-height: 150px;  // height will be minimum 150px, later it will increase if needed to avoid overflow.
                    max-height: 140px; // height will adjust with content until it reaches 140px after that it will not grow in height; 

                    max-width: 100%; // its intrinsic width is smaller than its container, the image will not be 
                                    //forced to stretch and become larger, thus preventing pixelation.
                    width: 100%;   // stretches or shrinks image to fit into a container. 
                        
                viewport units
                    The viewport — which is the visible area of your page in the browser you are using to view a site — also has a size. 
                    In CSS we have units which relate to the size of the viewport — the vw unit for viewport width, and 
                    vh for viewport height. Using these units you can size something relative to the viewport of the user.
                
                    1vh is equal to 1% of the viewport height, and 1vw is equal to 1% of the viewport width. 
                    You can use these units to size boxes, but also text
                



            <h2>Images, media and form elements</h2>
                
                Replaced Elements 
                    Image and videos are called replaced elements, that means CSS can not affect their interal layouts
                    Only their position in the page can be manipulated. 
                    
                    max-width: 100%;
                    or, 
                    object-fit: cover; // maintains aspect ratio but crops part of the image if needed to fit the container box. 
                    object-fit: contain; // maintains aspect ratio but might result in letterboxing if box is smaller than the intrinsic size.
                    object-fit: fill;   // does not maintain the aspect ratio just fills the box
                
                    in grid or flex container img element aligned to the start of the container cell by default, unlike other elements that
                    stretches to fill up the whole container

                Styling form elements
                    - You should take care when changing the styling of form elements to make sure it is still obvious to 
                        the user they are form elements.
                    - many of the more complex input types are rendered by the operating system and are inaccessible to styling. 
                        You should therefore always assume that forms are going to look quite different for different visitors 
                        and test complex forms in a number of browsers.
                    
                    resetting / normalizing form elements 
                        because, 
                        1. In some browsers, form elements do not inherit font styling by default
                        2. Across browsers, form elements use different box sizing rules for different widgets
                        3. For consistency, it is a good idea to set margins and padding to 0 on all elements, 
                            then add these back in when styling particular controls
                        4. In addition to the rules mentioned above, you should also set overflow: auto on <textarea>s 
                            to stop IE showing a scrollbar when there is no need for one
                        
                        putting it all together, 
                            button,
                            input,
                            select,
                            textarea {
                                font-family: inherit;
                                font-size: 100%;
                                box-sizing: border-box;
                                padding: 0;
                                margin: 0;
                            }

                            textarea {
                                overflow: auto;
                            }


                            

            <h2>Styling HTML table</h2>

                1. Normally table column's width is determined by how much contnet they contain which results in inconsistent
                    widths, on the other hand table-layout: fixed; is used to set fixed width to table columns 
                    with percentage values it can be responsive too. 
                
                    table { 
                        table-layout: fixed; 
                        width: 100%;
                    }
                    
                    table th:nth-child(1) { 
                        width: 15% 
                    }

                    table thead th:nth-child(2) { 
                        width: 85% 
                    }

                    The entire column width follows the width of its heading. 
                
                2. With border-collapse: collapse; set, the borders collapse down into one.

                3. use different fonts add pading, letter spacing on table elements also use padding. 
                    thead th:nth-child(odd) { } 
                    tbody tr:nth-child(even) { } 
                    table td:nth-child( 2n-1 ) { } 
                



            <h2>Debugging CSS</h2>
                
                1. Use firefox developer tools; info, warning sign, styles and changes tab;
                2. Use developer tools, https://jigsaw.w3.org/css-validator/
                3. Consider specificity issues
                4. Understand that changing display type of an element will render other dimensional property ineffective
                    such as height and width will be ineffective on inline element. 
                5. Make a reduced test case or use divide and conquer strategy (- Mamunur Rashid) while removing ineffective code from the 
                    issue that you are encountering. 
                6. Finally, if you can't figure out then post it on codepen and ask others for help. 
                
            


            <h2>Organizing CSS</h2>
                
                General guidance 
                    1. Follow your team styling guide for CSS. 
                    2. Same naming convention for classes. 
                    3. One method for describing color. 
                    4. Maintian consistent formatting with spacing and indentations
                    5. Each declaration on its own line 
                    6. Each selector of a selector list on its own line
                    7. Avoid using #id selector
                    8. Avoid overly specific Selectors
                    9. Avoid overriding rules as much as possible.
                    10. Use blocks of comments between logical section in your stylesheet

                        /* || General styles */
                            body
                            p
                            h1, h2, h3, h4, h5
                            ul and ol
                            The table properties
                            Links
                            blockquote 
                        
                        /* || Typography */
                        
                        ...
                        
                        /* || Header and Main Navigation */


                    11. Comment your source URL in your CSS if you are following a tutorial. 
                    12. Comment declarations that are written to solve specific problems such as cross browser copatibility
                    13. Make utility class and define rulesets in your stylesheet if you are intending to using that on 
                        different elements and/or multiple times. 
                    14. Gather all the styling rules that will be used in every page of your website such as header, navigation, 
                        logo, page layout etc, and mark that styling block with an appropraite block comment such as /* || SITEWIDE*/
                    15. Finally add CSS rules for specific things, broken down by the context, page, or even component in which they 
                        are used.

                            /* || STORE PAGES */

                            .product-listing { ... }

                            .product-box { ... }

                    16. - Break larger stylesheets into multiple smaller ones. 
                        - Create a main stylesheet that will include all the global rules and link to multiple stylesheets that were
                            creted for specific sections.
                        - Normal rules of the cascade apply, with rules in stylesheets linked later coming after rules in stylesheets linked earlier.

                    17. OOCSS
                        Object Oriented CSS 
                        In OOCSS, you would create one pattern called media that would have all of the common CSS for both patterns — a base class 
                        for things that are generally the shape of the media object. Then we'd add an additional class to deal with those tiny 
                        differences, thus extending that styling in specific ways.

                        https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook/Media_objects

                    18. BEM 
                        block element modifier, class naming and ruleset declarations convention that is used in large projects. 

                    19. CSS build systems
                        A pre-processor runs over your raw files and turns them into a stylesheet, whereas a post-processor takes 
                        your finished stylesheet and does something to it — perhaps to optimize it in order that it will load faster.
                        SASS (pre-processor), cssnano (post-processor)

                    20. Custom property
                        CSS variable declare variable by --variable-name: value; 
                        it is block scoped and :root{ --global-variable: value; } // available over all other blocks;
                        property: var(--variable); // to retrive value from --variable and set to property

                        

                        
            <h2>Fundamental text styling</h2>
                
                CSS properties that applies styles to texts are of following two categories, 

                1. Font styles          =>  font-family, font-weight, font-style etc,  how the font looks
                2. Text layout styles   =>  font-alignment, letter spacing, line height etc, how the text fits inside the box

                - Color 
                    p {
                        color: red; 
                    }

                    Sets color to the foreground content of the selected element, usually text and underline or overline.
                    

                - Font Family 
                    p {
                        font-family: arial; 
                    }
                    
                    This would make all paragraphs on a page adopt the arial font

                - Web Safe Fonts 
                    There are only a certain number of fonts that are generally available across all systems and 
                    can therefore be used without much worry. These are the so-called web safe fonts.
                    Such as Arial, Courier New, Georgia, Times New Roman, Trebuchet MS, Verdana. 

                - Default Fonts 
                    CSS defines five generic names for fonts: serif, sans-serif, monospace, cursive, and fantasy. 
                    These are very generic and the exact font face used from these generic names can vary between 
                    each browser and each operating system that they are displayed on.

                    The last two are less predictable.

                - Font Stacks 
                    This involves a font-family value consisting of multiple font names separated by commas, e.g.,
                    p {
                        font-family: "Trebuchet MS", Verdana, sans-serif;
                    }
                    // load Verdana if Trebuchet MS is not available or load any available sans-serif font if all other fails. 

                    * Font name that are more than two words need to be enclosed by quotes. 
                
                - Font Size Units 
                    - px or pixels, it is an absolute unit, how high you want your text to be. 
                    - em , relative to the parent element or more specifically relative to the width of the capital letter "M"
                        in its parent element. Nesting different font-size elements can lead to complex situations while using
                        this element. 
                    - rem, relative to the root element, <html>; easier to maintain. 

                    font-size is inherited from parent element by default the root element's font-size is set to 16 px by browser
                    and <h1></h1> 's font-size is set to 2em

                    * use rem if possible and avoid setting font-size on container elements. 
                    * It is a good idea to set root element's font-size to 10px then other (r)em measurement is just pixel/10
                    * It is a good idea to list all your font-size rulesets in a designated area in your stylesheet, 
                        so they are easy to find.

                font-style: normal ( normal font or to turn italic off), 
                            italic (use italic version or fallback to oblique), 
                            oblique (slanted font to simulate italic) 

                font-weight: bold, normal,
                             lighter, bolder, (one step lighter or bolder than its parent's)
                             100 - 900, (numeric value)

                text-transform: none, uppercase, lowercase, uppercase, capitalize, full-width. 
                text-decoration: none, underline, overline, line-through
                text-decoration: overline wavy red; // text-decoration-line text-decoration-style text-decoration-color
                text-shadow: 1px 2px 3px red; 
                            // horizontal offset   vertical offset   blur radius    color ( defaults to parent's)
                            // also accepts negative value and multiple shadows can be used, separated by comma. 
                
                Text Layout 

                    text-align: left, right, center, justify
                        controls how the text is aligned within the contatining content box 
                        "justify" makes the text spread out varying the gaps between words to make all the line of text of same width.
                    
                    line-height: most-length-units or 
                                unit-less-value which is multiplier of selected element's font-size
                                recommended
                    
                    letter-spacing: 1px; 
                    word-spacing: 1px; 
                    
                    Font shorthand
                        Many font properties can also be set through the shorthand property font. 
                        These are written in the following order: 
                            font-style, font-variant, font-weight, font-stretch, font-size, line-height, and font-family.

                        * Among all those properties, only font-size and font-family are required when using the font shorthand property.

                        * A forward slash has to be put in between the font-size and line-height properties.

                        * A full example would look like this:
                            font: italic normal bold normal 3em/1.5 Helvetica, Arial, sans-serif;

            
            
            <h2>Styling Lists</h2>
            
                list-style: list-style-type list-style-image list-style-position; 
                is a shorthand for
                list-style-type: none, disc, square, decimal, georgian, circle, upper-roman, lower-alpha; // and so on 
                list-style-image: url("image.ext"), none; 
                list-style-position: inside, outside;
                
                <li start="4" reversed>List item</li>
                <li type="a">List item</li>
                <li value="10">List item</li>
                
                * maintian vertical rhythm and horizontal spacing according to other elments around lists. 
                * use background-* properties to implement custom image as bullet points with list items so that you will be
                    able to better control the background image. 
                * use list-style-type fallback while using an image as bullet. 
                * make dt definition term bold

            


            <h2>Styling Links</h2>

                Links states
                    link: a link with a destination not just a named anchor. 
                    visited: link that is already in browser history. 
                    focus: a link that is focused by keyboard (by pressing tab) or other similar technology. 
                    hover:  when a link is hovered by a user's mouse pointer. 
                    active: when a link is clicked. 
                
                Default Styles
                    Links are underlined
                    Unvisited links are blue
                    Visited links are purple
                    Hovered links make mouse pointer change to a little hand icon
                    Focused links have outline around them 

                You can style link anyway you want but remember to keep the following characteristics to them,
                    1. Use underlining for links, but not for other things. If you don't want to underline links, 
                        at least highlight them in some other way.
                    2. Make them react in some way when hovered/focused, and in a slightly different way when activated.

                You can manipulate default link styling by manipulating the following properties, 
                    color:
                    cursor: pointer
                    outline: same as border but doesnt take up space in the box rather just sits on top over the background

                always maintain the order in which you might style links as link styles build up on previous states of it i.e., 
                    Love Fears HAte 
                    a, a:link, a:visited, a:focus, a:hover, a:active

                Note: 
                    1. The underline has been created using border-bottom, not text-decoration — some people prefer this because 
                        the former has better styling options than the latter. It's also drawn a bit lower so it doesn't cut across 
                        the descenders of the word being underlined (e.g., the tails on g and y).

                    2. The border-bottom value has been set as 1px solid, with no color specified. Doing this makes the border adopt 
                        the same color as the element's text, which is useful in cases like this where the text is a different color 
                        in each case.

                    3. Finally, a:active is used to give the links an inverted color scheme while they are being activated, 
                        to make it clear something important is happening!

                Navigation bar with unordered list
                    - spaces/line breaks in between inline block elements create spaces on the page, just like the spaces in between words;
                    - li is a block element.
                

                
                
                <h2>Web Fonts and text styling with custom fonts</h2>

                    You can use the font stack to specify preferred fonts, followed by web-safe alternatives, 
                    followed by the default system font. However, this increases your workload because of the 
                    testing required to make sure that your designs work with each font.

                        p {
                            font-family: Helvetica, "Trebuchet MS", Verdana, sans-serif;
                        }


                    Web Fonts
                        CSS allows you to specify font files, available on the web, to be downloaded along with your 
                        website as it's accessed. This means that any browser supporting this CSS feature can display 
                        the fonts you've specifically chosen

                        @font-face {
                            font-family: "myfont"
                            src: url("myfont.woff2");
                        }

                        html {
                            font-family: "myfont", sans-serif;
                        }


                        1. All major browsers support WOFF/WOFF2 (Web Open Font Format versions 1 and 2).

                        2. WOFF2 supports the entirety of the TrueType and OpenType specifications, including variable fonts, 
                            chromatic fonts, and font collections.

                        3. The order in which you list font files is important. If you provide the browser with a list of multiple 
                            font files to download, the browser will choose the first font file it's able to use. 
                            That's why the format you list first should be the preferred format — that is, WOFF2 — with the older 
                            formats listed after that. Browsers that don't understand one format will then fall back to the next 
                            format in the list.

                        4. If you need to work with legacy browsers, you should provide EOT (Embedded Open Type), 
                            TTF (TrueType Font), and SVG web fonts for download. This article explains how to use the Fontsquirrel 
                            Webfont Generator to generate the required files.


                    using custom font 
                        chose custom font and download ttf from Fontsquirrel or other font distributor 
                        upload and generate woff, woff2, eot, svg and ttf format to support all browsers
                    
                        @font-face {
                            font-family: 'croissant';
                            src: url('fonts/webfont/croissantone-regular-webfont.woff2') format('woff2'),
                                 url('fonts/webfont/croissantone-regular-webfont.woff') format('woff'),
                                 url('fonts/webfont/croissantone-regular-webfont.ttf') format('truetype'),
                                 url('fonts/webfont/croissantone-regular-webfont.svg#croissant_oneregular') format('svg'), 
                                 url('fonts/webfont/croissantone-regular-webfont.eot?#iefix') format('embedded-opentype');
                            font-weight: normal;
                            font-style: normal;
                          
                          }

                    also check online font service such as google fonts
                    font-variant, font-stretch, unicode-range 
                    and variable fonts

                
                <h2>Css Layout: Normal Flow</h2>

                    What is normal flow ?

                        The way all elements in a webpage are positioned when you have not done anything to change their
                        position is called normal flow. 

                        since normal flow is designed to make a readable document, by starting in this way you're working 
                        with the document rather than struggling against it as you make changes to the layout.

                        you can change how elements behave either by adjusting their position in normal flow or by removing 
                        them from it altogether. Starting with a solid, well-structured document that's readable in normal 
                        flow is the best way to begin any webpage
                    
                    Block Element:

                        By default, a block level element's content fills the available inline space of the parent element 
                        containing it and grows along the block dimension to accommodate its content

                        By default, block-level elements are laid out in the block flow direction, which is based on the parent's 
                        writing mode (initial: horizontal-tb). Each element will appear on a new line below the last one, with 
                        each one separated by whatever margin that's been specified.

                    Inline Element: 

                        The size of Inline elements is just the size of their content. You can't set width or height on 
                        inline elements — they just sit inside the content of block level elements
                        
                        Inline elements behave differently. They don't appear on new lines; instead, they all sit on the same 
                        line along with any adjacent (or wrapped) text content as long as there is space for them to do so 
                        inside the width of the parent block level element. If there isn't space, then the overflowing content 
                        will move down to a new line.

                        You can make an inline element block by display:block or inline-block and set width or height to it but
                        that doesn't make them nest another block level elements in them. 

                    Margin collapsing 
                        If two adjacent elements both have a margin set on them and the two margins touch, the larger of 
                        the two remains and the smaller one disappears.

                
                
                
                <h2>Flexible Box Layouts</h2>
                    
                    The Flexible Box Module, usually referred to as Flexbox, is a one-dimensional layout method for arranging 
                    items in rows or columns. Items flex (expand) to fill additional space or shrink to fit into smaller spaces.

                    Flexible Box: 
                        If we set "display: flex" to a contianer/parent element then all its children will become flexible boxes 
                        The flex parent/container element will behave as a block element with respect to the other element on 
                        the web page. 
                        Also, you can set the parent container to "dispaly: inline-flex", in that case it's children
                        becomes flex items or flexible boxes but the parent container itself will behave as an inline element with 
                        respect to other elements on that web page.

                    The Flex Model: 
                        The main axis is the axis running in the direction the flex items are laid out in (for example, 
                            as rows across the page, or columns down the page.) The start and end of this axis are called 
                            the main start and main end.

                        The cross axis is the axis running perpendicular to the direction the flex items are laid out in. 
                            The start and end of this axis are called the cross start and cross end.

                        The parent element that has display: flex set on it is called the flex container.

                        The items laid out as flexible boxes inside the flex container are called flex items


                    Flex Direction 
                        In which direction flex-items or flex boxes are laid out in; 
                        which direction the main axes run 
                        
                        flex-direction: row (default), column, row-reverse, column-reverse; 
                        
                        also, row-reverse and column-reverse will alter the start and end of main and cross axis respectively. 

                        flex-direction does not alter the way the flex items are laid out, Flex items will always be laid out 
                        along the main axis; flex-direction selects the main axis and the cross axis is set perpendicular to that 
                        automatically. 

                        
                    Flex wrap 
                        When you have a fixed width or height in your layout that eventually your flexbox children 
                        will overflow their container, breaking the layout.
                        
                        flex-wrap: nowrap (default), wrap, wrap-reverse; // to flex container 
                        flex: 200px; // to flex items/boxes.
                        in case of a flex wrap, consider each flex line as a separate flex container as flex-grow and flex-shrink 
                        will not depend on other flex lines. 


                    "flex-flow" shorthand 
                        it is a shorthand for flex-direction and flex-wrap ; 
                        flex-flow: row wrap; 


                    The flex items or flexboxes will match height in the block direction / cross axis with the tallest flex item and 
                    will stretch in the main axis/ flex / inline direction to cover whole width of the parent container. 


                    Flexible sizing of flex items
                        flex: non-negative integer value that indicates proportion of space that will be alotted to it with respect to
                                other flex items. 

                        suppose, total width of the viewport is 930px and total spare width available in the flex 
                        container is 900px after all padding and margins are set, then if flex: 1 is set, then all flex items will 
                        be given a total width of 300px each
                        you can translate that principle to logical values or if flex direction is set to column. 

                        Also height of a flex item is determined by the content conatained in it. 

                        you can set a specific flex item to have a certain proportion of space different from its siblings e.g., 

                        article { 
                            flex: 1; // all flex items will be given equal portion of space
                        }

                        article:nth-of-type(3) {
                            flex: 2; // the third flex item will be given twice the space of the other flex items. 
                        }

                        if last two declarations were used with 3 flex items then, 
                            there will be 4 equal portion 
                            1 portion would be given to first two felx items each and 
                            2 portions would be given to the third flex item.


                    Minimum Flex size 
                        article {
                            flex: 2 200px; 
                        }
                        article:nth-of-type(3) {
                            flex: 1 200p;
                        }

                        each flex item will be given minum 200px space after that all available spare spaces will be shared among
                        all flex items


                    Flex items alignment
                        align-items: stretch (default), center, flex-start, flex-end; // along cross axis Y
                        justify-content: flex-start (default), flex-end, center, space-around, space-between // along main axis X
                        these two css properties should be used by selecting the flex-container.
                    
                        you can also override align-items with align-self and justify-content with justify-self by selecting
                        specific flex items elements.


                    Flex item ordering 
                        By default, all flex items have an order value of 0.
                        Flex items with higher specified order values will appear later in the display order 
                            than items with lower order values.
                        Flex items with the same order value will appear in their source order.
                        You can set negative order values to make items appear earlier than items whose value is 0


                    Flexbox nesting 
                        can be nested; for that you need to set "display: flex" to a flex item which intends to nest 
                        other flex items; initially all flexboxes or flex items are set to display: block; 
                    

                    "flex" shorthand 
                        is a shorthand for flex-grow, flex-shrink and flex-basis


                    flex-grow: Sets the flex grow factor of a flex item, accroding to which that item will be allotted aditional
                                space from free positive space


                    flex-shrink: Sets the flex shrink factor of a flex item, according to which that item will be shrinked in
                                    case of negative free space. Only shrinks upto "min-contnet" size - 
                                    the size that they become if they take advantage of any soft wrapping opportunities 
                                    available to them
                        Note: The flex shrink factor is multiplied by the flex base size when distributing negative space. 
                        This distributes negative space in proportion to how much the item is able to shrink, so that e.g. 
                        a small item won't shrink to zero before a larger item has been noticeably reduced."


                    flex-basis: Sets the initial main size of a flex item. 
                                It sets the size of the content box unless otherwise set with box-sizing.

                                Is flex-basis set to auto, and does the item have a width set ? If so, the size will be based on that width.
                                Is flex-basis set to auto or content, If so, the size is based on the item size.
                                Is flex-basis a length unit, but not zero? If so this is the size of the item.
                                Is flex-basis set to 0? if so then the item size is not taken into consideration for the space-sharing calculation.

                    *** it is advised against using flex longhand properties. 
                        
                    If we took all of the items and added up their widths (or heights if working in a column), 
                    is that total less than the total width (or height) of the container? If so, 
                    then you have positive free space and flex-grow comes into play.

                    If we took all of the items and added up their widths (or heights if working in a column), 
                    is that total more than the total width (or height) of the container? If so, you have negative 
                    free space and flex-shrink comes into play.

                    *** Each new row (or column when working by column) is an independent flex line in the flex container. 
                        Space distribution happens across the flex line.

                    https://developer.mozilla.org/en-US/docs/Web/CSS/flex


                    Setting flex: initial resets the item to the initial values of Flexbox. 
                    This is the same as flex: 0 1 auto. In this case the value of flex-grow is 0, so items will not 
                    grow larger than their flex-basis size. The value of flex-shrink is 1, so items can shrink if they 
                    need to rather than overflowing. The value of flex-basis is auto. Items will either use any size 
                    set on the item in the main dimension, or they will get their size from the content size.

                    Using flex: auto is the same as using flex: 1 1 auto; everything is as with flex:initial but in this 
                    case the items can grow and fill the container as well as shrink if required.

                    Using flex: none will create fully inflexible flex items. It is as if you wrote flex: 0 0 auto. 
                    The items cannot grow or shrink but will be laid out using flexbox with a flex-basis of auto.

                    The shorthand you often see in tutorials is flex: 1 or flex: 2 and so on. This is as if you used flex: 1 1 0 
                    or flex: 2 1 0 and so on, respectively. The items can grow and shrink from a flex-basis of 0.


                    display: contents 
                        The contents value of the display property is a new value that is described in the spec as follows:

                        "The element itself does not generate any boxes, but its children and pseudo-elements still generate 
                        boxes as normal. For the purposes of box generation and layout, the element must be treated as if it 
                        had been replaced with its children and pseudo-elements in the document tree."

                    gap between flex-items: 
                        gap: row-gap column-gap; // on flex container
                    
                    
                    do I only need to control the layout by row or column – use a flexbox
                    do I need to control the layout by row and column – use a grid


            
            <h2>CSS Grid</h2>
                
                A grid is a set of intersecting horizontal and vertical lines that creates a collection of small square areas
                that are called grid cells and each vertical series of grid cells are called column tracks and each horizontal
                series of grid cells are called row track. 

                In CSS we define a container area as a grid with 
                    display: grid;
                    or,
                    display: inline-grid;

                and we define column and row track by, 
                    grid-template-columns: column-track-size column-track-size column-track-size; 
                    grid-template-rows: row-track-size row-track-size row-track-size; 

                above two properties create explicit grid tracks and implicit grid tracks are created when grid items are 
                created when items are placed into grid by auto placement algorithm

                For example a grid container contains three grid items and we defined 3 columns tracks and grid items are 
                placed into the grid according to column size but rows are automatically defined to contain grid items 
                according to grid-item's content sizing, the automatically defined row track is called implicit row track. 
                
                    .container {
                        display: grid; 
                        grid-template-columns: 100px 200px 15%;              // 3 column tracks
                        grid-template-rows: 100px 200px; // 2 row tracks     // total 6 grid cells

                        gap: 10px 2em;                                       // row-gap column-gap
                        grid-auto-flow: row;                                 // implicit grid track direction
                        grid-auto-rows: 100px;                               // implicit row track 
                    }

                * Flexible grid tracks and repeat function
                    .container {
                        display: grid; 
                        grid-template-columns: repeat(3, 1fr);              // same as grid-template-columns: 1fr 1fr 1fr; 
                    }
                    // 1fr means 1 fraction of available space

                * Minimum and maximum size for a track
                    grid-auto-rows: minmax(100px, auto);

                * As many columns as will fit
                    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 

                        divide viewport width by 200px and decide total number of columns possible and create them
                        allot the rest of the available space (that is smaller than 200px)
                        among all columns according to ratio of 1fr each. 

                    - auto-fill creates empty column tracks if space is available and do not collapse them
                    - auto-fit also does the same but it will collapse the empty columns and gaps and allot them 
                        to non empty columns 
                    - both of these properties create explicit content tracks. 
                    
                * By default implicit grid tracks are auto sized by their content and you can not addres them by 
                    grid line number and place content in them, contents are auto placed in them. 

                * To place grid item in the desired area of our grid we target the position with grid lines such as 
                    column line and row line. We can also place grid items in our desired areas by grid-template-areas

                * When we define grid we define grid tracks not the lines, grid them gives us numbered lines, 
                    grid line numbers start from 1 at the start of a line and also starts from -1 to -n from 
                    the end of the line. 

                * when placing an item we target the line rather than track.

                * Grid item placement line properties
                        grid-column-start: 
                        grid-column-end: 
                        grid-row-start: 
                        grid-row-end: 

                    shorthand for row and column line, 
                        grid-column: start / end; 
                        grid-row: start / end; 

                    shorthand for grid-column and grid-row, 
                        grid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end; 


                * By default grid area spans 1 track so you can omit the end value if you want to span 1 track from start. 
                
                * You can also use span value to denote start and end line for a grid item, 

                    grid-column: span 3 / 4 
                        // grid area will start from column line 4 and span 3 line upwards

                    grid-row: 1 / span 3 
                        // grid area will start from row line 1 and span 3 lines

                * Grid item positioning with grid template areas, 

                    .container {
                        display: grid; 

                        // for item placement in layout and overall layout composition
                        grid-template-areas: 
                        "header header"
                        "sidebar content"
                        "footer footer";

                        // to declare column tracks and sizes
                        grid-template-columns: 1fr 2fr; 
                    }

                    header  {   grid-area: header;  }
                    aside   {   grid-area: sidebar; }
                    article {   grid-area: content; }
                    footer  {   grid-area: footer;  }

                    The rules for grid-template-areas are as follows:
                        You need to have every cell of the grid filled.
                        To span across two cells, repeat the name.
                        To leave a cell empty, use a . (period).
                        Areas must be rectangular — for example, you can't have an L-shaped area.
                        Areas can't be repeated in different locations.
                        The value of grid-template-areas must show a complete grid, otherwise it is invalid 
                        (and the property is ignored).

                * Nesting grid 
                    you can set a grid item as grid container and its children will be grid items
                    but children will not inherit gap or content tracks from its parents. 
                        display: grid; 
                        grid-template-columns: repeat( 3, 1fr); 

                * Subgrid 
                    set a grid item's container as, 
                        display: grid;
                        grid-template-columns: subgrid; 
                    The nested grid will then use the parent grid tracks to layout items.

                * Multiple grid items can occupy same grid cells, in that case, the grid item that comes later in the source
                    will come on top while rendering but in case you want to change the order you can use 
                    z-index property on those grid items, items with higher z-index value will come on top.

                * "grid-tempalte" and "grid" shorthands

                    Before using any shorthand it is worth remembering that shorthands not only enable 
                    the setting of many properties in one go, they also act to reset things to their 
                    initial values that you do not, or cannot set in the shorthand. 
                    Therefore if you use a shorthand, be aware that it may reset things you have applied elsewhere.

                    .wrapper {
                            display: grid;
                            grid-template:
                            "hd hd hd hd   hd   hd   hd   hd   hd" minmax(100px, auto)
                            "sd sd sd main main main main main main" minmax(100px, auto)
                            "ft ft ft ft   ft   ft   ft   ft   ft" minmax(100px, auto)
                                / 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr ;
                        }

                        .wrapper {
                            display: grid;
                            grid: "hd hd hd hd   hd   hd   hd   hd   hd" minmax(100px, auto)
                            "sd sd sd main main main main main main" minmax(100px, auto)
                            "ft ft ft ft   ft   ft   ft   ft   ft" minmax(100px, auto)
                            / 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr ;
                        }


                * Implicit track direction and item order and packing style

                    grid-auto-flow: row dense; 
                        // implicit row tracks will be created to place items in grid 
                        // and pack them densely overriding the source order.

                    grid-tempalte-columns: 1fr 2fr 1fr; 

                * Grid and display: contents; 
                    // same as flexbox; child items becomes grid items such that parent container vanishes
                    
                * Naming grid lines while creating a grid

                    you can denote line names with grid lines while creating grid but line name can not be identical to
                    any css syntax and they do not need to be quoted. 

                    grid line name must be enclosed in third brackets and you can also use multiple names for single grid line

                    also if you append -start and -end after line names you can get implicit grid area and use that common 
                    name to place grid items into the grid. e.g., "content" in the following example, 

                        .wrapper {
                            display: grid;
                            grid-template-columns: [main-start] 1fr [content-start] 1fr [content-end] 1fr [main-end];
                            grid-template-rows: [main-start] 100px [content-start] 100px [content-end] 100px [main-end];
                        }

                        .thing {
                            grid-area: content;
                        }

                    We have seen how named lines create a named area, and this also works in reverse. Named template areas 
                        create named lines that you can use to place your items, use grid inspector to experience that. 

                    You can also use repeat() with track definition and line names and multiple lines can have same name. 

                
                * Box alignment in CSS Grid Layout 
                    box alignment specification 3 

                    - Two axis of grid layout 
                        block axis 
                        inline axis 


                    - Aligns all grid items on the block axis, 
                        align-items: auto
                                    normal
                                    start
                                    end
                                    center
                                    stretch
                                    baseline
                                    first baseline
                                    last baseline
                        // meant to be used by selecting the grid container 
                        // The align-items property sets the align-self property for all of the child grid items

                    - Aligns individual grid item on the block axis,
                        align-self: 


                    - Justifying items on the inline axis
                        justify-items: [same values as align-items] 
                        justify-self: [same values as align-self]
                        

                    - The specification details that the default behavior in align-self is to stretch, except for 
                        items which have an intrinsic aspect ratio, in this case they behave as start.
                        The reason for this, is that if items with an aspect ratio are set to stretch, 
                        this default would distort them.

                    - Shorthand properties
                        The place-items property is shorthand for align-items and justify-items.
                        The place-self property is shorthand for align-self and justify-self.
                        
                    - Center an item in a grid area
                        align-self: center; 
                        justify-self: center; 

                
                * Grid alignment in Parent Container 
                    If you have a situation where your grid tracks use an area that is smaller than the grid container, 
                    then you can align the grid tracks themselves, inside that container. 
                        place-content: align-content justify-content; 

                    possible values, 
                        normal start end center stretch space-around space-between space-evenly 
                        baseline first baseline last baseline

                    align-content: default is start 
                    justify-content: 
                    
                * Reordering and acessibility
                    Any time you reorder things with grid layout – or with flexbox – you only perform visual reordering. 
                    The underlying source is what controls things like text to speech, and the tab order of the document.

                    keep the visual and document source order in sync 
                    The key here is to keep testing, a very simple test is to tab around the document. Does that order 
                    still make sense? Check that you do not end up leaping from the top to the bottom of the layout in 
                    a peculiar way. If so that would be a sign that you need to address something about the layout.
                
                    keep semantics in document source, you should not omit semantic elements to apply visual styles.

                * Gap 
                    In terms of grid sizing, gaps act as if they were a regular grid track however nothing can be placed 
                    into the gap. The gap acts as if the grid line at that location has gained extra size, so any grid 
                    item placed after that line begins at the end of the gap.

                    The row-gap and column-gap properties are not the only things that can cause tracks to space out. 
                    Margins, padding, or the use of the space distribution properties in Box Alignment can all contribute 
                    to the visible gap – therefore the row-gap and column-gap properties should not be seen as equal to 
                    the "gutter size" unless you know that your design has not introduced any additional space with one 
                    of these methods.

                * Floats and other legacy layout method's properties doesn't work on grid or flex items
                    meaning in supported browsers grid and flex layout properties take precedence over other properties 
                    for alignment and so on. 
            
            
            
            <h2>Floats</h2>
                
                The float property was introduced to allow web developers to implement simple layouts involving an 
                image floating inside a column of text, with the text wrapping around the left or right of it. 
                The kind of thing you might get in a newspaper layout.

                The element with the float set on it is taken out of the normal layout flow of the document and stuck to 
                the left or right (depending on float value) side of its parent container. 

                Any content that would come below the floated element in the normal layout flow will now wrap around 
                it instead, filling up the space to the opposite side of the float as far up as the top of the 
                floated element. There, it will stop.

                    float: left , right; 

                if you want the following content from wrapping around the float or moving up you should clear it with, 
                    clear: left, right, both; // on the following element
                
                if you have a tall float and a short paragraph, with a box wrapped around both elements, in that case 
                to clear following item you could use, 
                    
                    1. on the wrapper box

                        .wrapper::after { 
                            content: "";
                            display: block;
                            clear: both;
                        }
                        //clearfix hack

                    2. 
                        overflow: auto; // any value other than visible or clip 

                        this creates a BFC - block formatting context which is like a mini layout inside your webpage 
                        where all enclosed elements will be contained within it, however it has a problem in case of 
                        overflow that might result in unexpected behaviour such as clip shadow or scrollbar

                    3. 
                        display: flow-root; 
                        // sole purpose of this property value is to create a BFC without unintended consequences.

            

            <h2>Positioning</h2>

                Positioning allows to override the normal document flow. 
                position: static (default), relative, absolute, fixed; 

                static
                    default positioning of an element on the webpage i.e., all elements in normal flow

                relative
                    This is very similar to static positioning, except that once the positioned element has taken its 
                    place in the normal flow, you can then modify its final position, including making it overlap 
                    other elements on the page. 
                    This means that it's relative to its original position within the parent element.
                    Relative positioned element is not taken out of normal document flow. 

                absolute 
                    absolute positioned elements are taken out of normal document flow, Instead, it sits on its own layer 
                    separate from everything else and it is positioned relative to its containing element

                    If no ancestor elements have their position property explicitly defined, 
                    then by default all ancestor elements will have a static position. The result of this 
                    is the absolutely positioned element will be contained in the initial containing block outside of the
                    html element itself 

                    it means that we can create isolated UI features that don't interfere with the layout of other elements 
                    on the page. For example, popup information boxes, control menus, rollover panels, UI features that can 
                    be dragged and dropped anywhere on the page, and so on.

                fixed 
                    fixed positioning usually fixes an element in place relative to the visible portion of the viewport
                    fixed positioned element is taken out of normal document flow
                    you can create useful UI items that are fixed in place, like persistent navigation menus that are 
                    always visible no matter how much the page scrolls.

                sticky
                    it is a hybrid between relative and fixed position. It allows a positioned element to act like 
                    it's relatively positioned until it's scrolled to a certain threshold (e.g., 10px from the top 
                    of the viewport), after which it becomes fixed.
                    Sticky elements are "sticky" relative to the nearest ancestor with a "scrolling mechanism",

                position specifier
                    top: 
                    bottom: 
                    right: 
                    left: 
                    // defines offset from target elements position in length units such as px, % , mm etc. 
                    margins still affect positioned elements. Margin collapsing doesn't, however.
                    you can resize elements using these properties
                

                Identifying containing block
                    If the position property is static, relative, or sticky, the containing block is formed by 
                    the edge of the content box of the nearest ancestor element that is either a block container 
                    (such as an inline-block, block, or list-item element) or establishes a formatting context 
                    (such as a table container, flex container, grid container, or the block container itself).

                    If the position property is absolute, the containing block is formed by the edge of the padding 
                    box of the nearest ancestor element that has a position value other than static 
                    (fixed, absolute, relative, or sticky).

                    If the position property is fixed, the containing block is established by the viewport (in the 
                    case of continuous media) or the page area (in the case of paged media).

                    If the position property is absolute or fixed, the containing block may also be formed by the 
                    edge of the padding box of the nearest ancestor element that has the following:
                        A transform or perspective value other than none
                        A will-change value of transform or perspective
                        A filter value other than none or a will-change value of filter (only works on Firefox).
                        A contain value of paint (e.g. contain: paint;)
                        A backdrop-filter other than none (e.g. backdrop-filter: blur(10px);)

                    Note: The containing block in which the root element (<html>) resides is a rectangle called 
                        the initial containing block. It has the dimensions of the viewport (for continuous media) 
                        or the page area (for paged media).


                    z-index and visibility of overlapping elements
                        Any positioned element take precedence over static positioned element in terms of visibility
                        Any element that overlaps other element and comes later in document source, comes on top 
                        

                        "z-index" is a reference to the z-axis; 
                        Web pages also have a z-axis: an imaginary line that 
                        runs from the surface of your screen towards your face. z-index values affect where positioned 
                        elements sit on that axis; positive values move them higher up the stack, negative values move 
                        them lower down the stack. By default, positioned elements all have a z-index of auto, which 
                        is effectively 0.

                        Note that z-index only accepts unitless index values; 

                
            <h2>Multi-Column Layout</h2>
                
                The multiple-column layout specification provides you with a method for laying content out in columns, 
                as you might see in a newspaper. This article explains how to use this feature.

                you can enable multiple column layout in a container element by either of the following, 
                1. 
                    column-count: n // positive integer; browser will give you equally sized n number of columns

                2. 
                    column-width: length units // e.g., 200px, 
                    // browser will divide the container width by given width and give you most numer of columns
                    // possible but if it is not evenly divisible, remainder width will be distributed to all columns

                
                styling the columns

                    Changing the size of the gap between columns using the 
                        column-gap: 10px; 

                    Adding a rule between columns with 
                        column-rule: column-rule-width column-rule-style column-rule-color; 
                        // accepts same value as border; 

                    you can not style columns individually

                    Something to take note of is that the rule doesn't take up any width of its own. 
                    It lies across the gap you created with column-gap. To make more space on either side of the rule, 
                    you'll need to increase the column-gap size.

                span columns 
                    column-span: none, all; // can not span some columns it is either all or none; 
                
                avoid fragmented box accross columns
                    break-inside: avoid; 
                    page-break-inside: avoid; 
                    // add these properties to the box you want to be in once piece while rendered on a page. 
            
        
        
        
            <h2>Responsive Design</h2>

                HTML is fundamentally responsive. If you create a web page containing text and resize the browser window, 
                or display the page on a device with a smaller screen, then the browser will automatically reflow the text 
                to fit the window. This is called a liquid layout.
                The problem with this layout, though, is that the site would look squashed on smaller screens 
                (as seen below) and have unreadably long line lengths on larger ones.

                The alternative is to create a fixed width layout, which sets elements to a fixed size in pixels.
                The problem with this approach is that you will get a horizontal scrollbar on screens smaller than 
                the site width (as seen below), and lots of white space at the edges of the design on larger screens.
                
                3 requirements for responsive web design
                        1. fluid grid
                        2. fluid images
                        3. media query
                        and also responsive typography may help 

                Media queries
                    The points at which a media query is introduced, and the layout changed, are known as breakpoints.
                    
                    A common approach when using Media Queries is to create a simple single-column layout for narrow-screen 
                    devices (e.g mobile phones), then check for larger screens and implement a multiple-column layout when 
                    you know that you have enough screen width to handle it. This is often described as mobile first design.

                vw units with font-size 
                    You should never set text using viewport units alone.
                
                    There is a solution, and it involves using calc(). If you add the vw unit to a value set using a 
                    fixed size such as ems or rems then the text will still be zoomable. Essentially, the vw unit 
                    adds on top of that zoomed value:

                    h1 {
                        font-size: calc(1.5rem + 3vw);
                    }

                viewport meta tag
                    <meta name="viewport" content="width=device-width,initial-scale=1">
                        sets mobile browsers viewport width to their device width and intial zoom scale to 100%
                        So you should always include the above line of HTML in the head of your documents.

                    There are other settings you can use with the viewport meta tag, however in general the above 
                    line is what you will want to use.

                    initial-scale: Sets the initial zoom of the page, which we set to 1.
                    height: Sets a specific height for the viewport.
                    minimum-scale: Sets the minimum zoom level.
                    maximum-scale: Sets the maximum zoom level.
                    user-scalable: Prevents zooming if set to no.

                    You should avoid using minimum-scale, maximum-scale, and in particular setting user-scalable to no. 
                    Users should be allowed to zoom as much or as little as they need to; preventing this causes 
                    accessibility problems.

                    @viewport should not be used. it is deprecated

                
                
                
            <h2>Media Queries</h2>

            @media media-type and (media-feature-rule) {
                /* CSS rules go here */
                }

                1. media-type can be all, screen or print // it is optional, defaults to all if omitted
                2. media-featur-rule or media expression is acutally a conditional statement 
                3. css rules that will be applied if that media expression is satisfied


            media features Rules
                width, min-width, max-width, height, min-height, max-height: 200px; 
                orientation: landscape, portrait // by default desktop browser's orientation is landscape
                hover: hover, none 
                // if the user has the ability to hover over an element, which essentially means they are 
                // using some kind of pointing device; touchscreen and keyboard navigation does not hover.

                Also in Level 4 is the pointer media feature. This takes three possible values, none, fine and coarse. 
                A fine pointer is something like a mouse or trackpad. It enables the user to precisely target a small 
                area. A coarse pointer is your finger on a touchscreen. The value none means the user has no pointing 
                device; perhaps they are navigating with the keyboard only or with voice commands.

            complex media queries with logical operators
                
                and: 
                    @media screen and (min-width: 600px) and (orientation: landscape) {
                        body {
                            color: blue;
                        }
                    }
                
                or: 
                    @media screen and (min-width: 600px), screen and (orientation: landscape) {
                        body {
                            color: blue;
                        }
                    }
                    // or denoted by comma in between conditions in case of media queries 

                not: 
                    @media not all and (orientation: landscape) {
                        body {
                            color: blue;
                        }
                    }

            Approach to design a responsive website 
                Choose your breakpoints depending on the following considerations 
                1. Make sure the webpage content is readable in small and large screens comfortably. 
                2. Your webpage visual representation is consistent accross different viewport sizes and elements are
                    arranged in a logical order so it make sense to the viewer. 
                3. You can chose either mobile first or desktop first design approach but mobile first is the best 
                    practice as it is rendered in a single column layout so you just have to arrange the source in a 
                    logical order that best serves the user's interest. 

                
            Viewport meta tag 
                <meta name="viewport" content="width=device-width,initial-scale=1">
                use this line so that your website is properly rendered in mobile devices. 
                Stops mobile browsers from lying their viewport width. 

            
                

            <h2>Legacy Layout Methods</h2>
                
                uses float clear and divide the useable area by desired number of columns and define css rules for columns 
                and rows and other margin for column gutters, height is the problem

                flexbox grid are created with flex-basis set to width desired and defining pre determined width needed 
                for different sized columns

                other css grid frameworks like bootstarp and foundation also calculates the column and their
                width the same way and set the values using % (percentages) to make grid columns fluid. 


            <h2>Supporting Older Browsers</h2>
                

                A well structured document as a source so that the normal flow of your page makes sense 
                A user with a very limited feature phone might not get much of your CSS, but the content 
                will flow in a way that makes reading easy.
                If you remove your stylesheet, does your content make sense?


                Fallback methods
                    There are a number of layout methods which can be used in a similar way to this float example. 
                    You can choose the one that makes the most sense for the layout pattern you need to create.
                
                Float and clear
                    As shown above, the float and clear properties cease to affect the layout if floated or cleared items 
                    become flex or grid items.
                
                display: inline-block
                    This method can be used to create column layouts, if an item has display: inline-block set 
                    but then becomes a flex or grid item, the inline-block behavior is ignored.
                
                display: table
                    The method of creating CSS Tables described in the introduction to these lessons can be used as a 
                    fallback. Items that have CSS table layouts set on them will lose this behavior if they become flex 
                    or grid items. Importantly, the anonymous boxes created to fix up the table structure are not created.
                
                Multiple-column Layout
                    For certain layouts you could use multi-col as a fallback, if your container has any of the column-* 
                    properties defined on it and then becomes a grid container, the multicol behavior will not happen.
                
                Flexbox as a Fallback for Grid
                    Flexbox has greater browser support than Grid due to being supported by IE10 and 11, although do 
                    check out the information later in this lesson explaining the rather patchy and confusing support 
                    for Flexbox in older browsers. If you make a flex container into a grid container, any flex property 
                    applied to the children will be ignored.


                Feature queries
                    @supports (display: grid){
                        
                    }

            
            <h2>Advanced CSS</h2>
                
                clip-path: polygon(4 co-ordinates seperated by commas)

                img is an inline element. 

                transform: translate(x, y) // move element relative to its original position

                position: absolute 
                position: relative 
                top: 
                left: 

                text-transform: 

                css animation can be done in two major ways 
                1. transition 
                2. @keyframes animationName { 0% { } 100% { } }

                can we nest div inside h1 element ? 

                backface-visibility: hidden; // to make animiton smooth

                animation: animation-name animation-duration animation-timing-function;

                display: inline-block ( respects height and width ) vs inline (takes margin and padding but 
                                        does not respect width or height). 
                                        
                transition: transition-property transition-duration transition-timing-function transition-delay;
                
                .btn:hover::after // because pseudo element can not have pseudo classes 
                A pseudo-class is a simple selector. A pseudo-element, however, is not, even 
                though it resembles a simple selector.

                In CSS, ::after creates a pseudo-element that is the last child of the selected element.
                It is inline by default.

                Note: The pseudo-elements generated by ::before and ::after are contained by the element's 
                formatting box, and thus don't apply to replaced elements such as <img>, or to <br> elements.

                animation-fill-mode: none, forwards, backwards 
                    forwards
                        The target will retain the computed values set by the last keyframe encountered during execution.
                    backwards
                        The animation will apply the values defined in the first relevant keyframe as soon as it is applied 
                        to the target, and retain this during the animation-delay period.

                transition and animation property should always be decalred inside element's initial state. 

                    
                how css works
                    parse html -> DOM   |
                                        |--> render tree ----> visual fromatting model ----------> Finally rendered 
                    parse css  -> CSSOM |                ( box model, floats, positioning)

                    
                    every css propert must have a value, 
                        is there a cascaded value --> (No) --> is the property inherited --> (No) --> specified value == initial value 
                                    |                                           |
                                    (Yes)                                       (Yes)
                                    |                                           |
                        specified value == cascaded value            specified value == computed value of the parent element


                    How cascade works 
                        * importance > specificity > source order of css style declaration; declaration that comes lates overwrites previous
                        * always put your author stylesheet last. 
                        * specificity also applies to pseudo-class's. Such as, :hover : active 
                    
                    How CSS values are processeed 
                        * all relative values are converted to pixels and any half pixel value rounded before being applied to elements. 
                        * inherited property always inherits the computed value not the declared value. 
                        * 
                            -> declared   (author declared value)
                            -> cascaded   (after cascade)
                            -> specified  (or initial value according to css specification if no value has been defined for the property)
                            -> computed   (relative to absolute value)  
                            -> used       (final calcualtion based on layout)  
                            -> actual     (rounded value that is applicable to pixel)

                    Visual formatting model 
                        * every element in html has a rectangular box around it,
                        
                        according to display type box'es are of type inline and block
                            box around element are called line-box and block-box that are around block element. 

                        fill-area: content + padding + border => area that gets filled with background image or color.

                    Floats are taken out of normal flow. 
                    two elements if collide their height diminishes you should use clearfix to resolve that. 

                    CSS architecture for maintainability, scalability and future growth
                        * Component Driven Design
                            1. Modular building blocks that make up interfaces 
                            2. Held together by layout of the page. 
                            3. Re-usable accross projects 
                            Components should be Independent 
                        * Atomic Design
                        * BEM (Block Element Modifier) syntax for class naming
                            1. A block should be an independent component of the UI and it should be re-usable
                            2. An element is kind of build block of a component, it does not have meaning of its own.
                            3. A modifier is just a css ruleset declaration that modifies either element or block.

                    SASS - Syntatically Awesome Style Sheets 
                        variables
                            reusable values such as colors, font-size, spacing etc, 
                            $variable_name or $variable-name: value;
                        
                        Nesting 
                            nest selectors withing indentation block or within block's braces uses "&" etc. 
                            
                        Operators 
                            for math operators like +, -, *, math.div()

                        partials and imports 
                            to write css in different files and import them all into a single file, e.g., 7-1 architecture
                            
                        mixins 
                            to write reusable piece of code / rulesets 
                        
                        functions 
                            return a value and takes arguments as well 
                        
                        extends/inheritance 
                            add selectors to a piece of code that extends it, the code is defined in a %placeholder

                        control directives 
                            for writing complex code using conditional and loops

                Layout 
                    * Maximum width of a layout 
                        max-width: 1140px; // or 1200px is standard in desktop first approach

                    * calculate width or height
                        width: calc(100% - 150px);


                    Flexbox 
                        * align-items: baseline; // 

                        * align text in a contatiner with flexbox 
                            display: flex; // in the container 
                            align-items: center; 

                        * push two flex items to two ends 
                            margin-right: auto; // on the flex-item at the left. 

                        * control space between flex rows
                            align-content: 

                    Grid 
                        * if you specify grid-row on an item that places it onto an area where other grid-item is 
                            explicitely placed by grid-row and grid-coloumn line number then it will simply place that 
                            grid-item which is being positioned to a new location but if you specify grid-column as well 
                            then it will overlap the already placed grid item. 

                        * use -1 while placing a grid-item in a grid container only when grid tracks are explicitely 
                            specified. 
                        
                        * naming grid line is a professional practice. 

                        * named set of grid lines 
                            col-start 1 / grid-end

                        * for small and simple layout we can use 'grid-template-areas' 


                        * align grid tracks to grid container 
                            justify-content: 
                            align-content: 

                            * only works when grid area is smaller than the container 
                        
                        * 'hole' in the grid can be caused by auto placement algorithm because it tries to keep the source order. 
                            It can be avoided by using 'dense' keyword with 
                            grid-auto-flow: row (or column) dense; 

                        * Before designing a grid decide the smallest grid item size and size your grid column and rows
                        
                        * start with how many rows you want and their height. 
                        
                        * If you intend to redefine your grid at breakpoints to adopt to different screen sizes, please 
                            consider naming your grid lines, that is mandatory. 
                        
                            * Then name and create columns 

                        * span a grid item multiple row by, 
                            grid-row: start/end; 
                            grid-row: start/span n;

                        * css 'fr' unit always shares remaining available space but never less than the minimum content. 
                        * minmax 
                        * auto-fit 
                        * auto-fill 


                Styling Elements
                    * skew an element 
                        transform: skew(10deg);

                    * scale an element 
                        transform: scale(1.5)   // a ratio, 1 is the original size of the element. 

                    * show background as text 
                        background-clip: text; 

                    * create a border around an element / box away from it 
                        outline: 2px solid green; //same values as border property
                        outline-offset: 20px; // outline starts 20 px further from the element's box 

                    * background-blend-mode: 

                    * multi line text with same style background 
                        box-decoration-break: clone;

                    * make text shape around an element according the element's shape 
                        shape-outside: circle( )

                    * apply filter on an image element 
                        filter: blur(10px) brightness(90%);

                    * Background video 
                        object-fit: cover; 
                        background-size: cover; 

                    * input elements 
                        if placeholder shown 
                            input:placehodler-shown { }

                        style the placeholder
                            input::placeholder {}

                    * An inline element inside a block parent container behaves just like text. 
                        so you can use 
                            text-align: center; // to center the element inside the container

                    * move background relative to the original position
                        background-position: 100%; // move background 100% to the right in the X axis 
                                                   // and center in the Y axis. 

                    * enable auto hyphenation in a paragraph
                        p {
                            hyphens: auto;
                        }

                    * show child elements as table cells 
                        dispaly: table-cell;
                        
                        and also set the parent container to 
                        display: table;

                    * css glyphs https://css-tricks.com/snippets/html/glyphs/

                    * display img as block element 
                    * Flexible images: width value set with percentages so image stays fluid. 
                    

                    SVG
                        * Best practice is to move away from icon-font to better alternative such as svg 
                        * import svg icon sprite file 
                        * change svg icon color 
                            fill: orangered; 
                        * we often size svg as square 
                        * 'currentColor' property value is same as current element's color; 
                            useful when we set icon's color to match the text color 
                        
                        * svg icon acts like inline elements, bit like text so there is a small extra space at 
                            the bottom of icon, you can remove it by
                                font-size: 0;
                                line-height: 0; 

                            or by setting their parent element to, 
                                display: flex;

                        * mask image 
                            mask-image: 
                            background-image takes precedence over mask-image 


                    Animation
                        * visibility: hidden and display: none is not animatable so opacity: 0 is used. 

                        * Infinite animation 
                            animation: name duration infinite;

                        * transition does not work on background-image; 

                        * chose from where transform begin 
                            transform-origin: center; // default 
    
                        *** Staged animation can be created with 
                            transition property and multiple transition value seperated by commas and transition delay. 

                    * background-origin: 

                    * z-index does not work without position property being set to some value. Except for flex-item or grid-item. 

                    * Object-fit: cover; 
                        will not work without both height and width set.

                    * use helper class on reusable components

                    * use thinner font to deliver a luxerious feel. 
                    
                * Applying styles to child elements 
                    * apply styles to all child but not the last child 
                        :not(:last-child) { }


                * Gradiant 
                    gradiant always forms perpendicular to gradiant line 

                * Responsive Web design 
                    * use em for media queries and rem for element's width and height 
                    
                    1. Desktop first, 
                        max-width: 600px; === width <= 600px
                    
                    2. Mobile first, 
                        min-width: 600px; === width >= 600px

                    * code order matters 

                * feature check and graceful degradation 
                    @supports (hover){

                    }
                    * always put the prefixed version before the original version. 

                * custom properties does not work with media queries 
                * apply breakpoint where it breaks.


                    
        <aside>

        </aside>
    </main>
</pre>
    <footer></footer>
</body>
</html>